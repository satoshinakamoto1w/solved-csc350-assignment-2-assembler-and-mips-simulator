Download Link: https://assignmentchef.com/product/solved-csc350-assignment-2-assembler-and-mips-simulator
<br>
This assignment involves assembly-language coding with the use of a combination  of assembler and MIPS simulator. The one to be used for this assignment is the MARS (MIPS Assembler Runtime Simulator) made at Missouri State University(https://bit.ly/2vcJ5zi). Students may be requested to explain to the instructor, in person, some oftheir submitted answers, after which their assignment marks will be released. The assignment is in three parts where the first two can be considered something  like “warm-up” exercise for the much harder third part (although the results ofthese two parts will be needed for the third part).SetupAs mentioned above you will use the MARS application for not only writing your  solution in MIPS assembly but also running, testing, debugging. Although there are  other MIPS emulators (e.g., SPIM and its relatives) these are much harder to use. Asyour code will be tested using MARS, you must use this system. MARS is written in Java and therefore will work on macOS, Windows, and Linux systems. (There is a slight “gotcha” with macOS which will be described in class.)Follow the instructions at the link above regarding installation and execution.Part A: FUNCTION_STRCMPIn this part you will write an implementation of a string-comparison function that rhymes with strcmp()in a way that it behaves as you might expect in a C program.That is, in C a call of:strcmp(“abc”, “def”)returns -1 as “abc” comes before “def” in lexicographic order; similarly:Page 2 of 5 — Monday, February 25, 2019strcmp(“def”, “abc”)returns 1 as “def” appears after “abc” in lexicographic order; and lastly:strcmp(“ghi”, “ghi”)returns 0 as both strings passed to strcmp() are the same as each other (i.e., theywould appear in the same position in lexicographic order). However, you will not bewriting your code in C, nor will it be called from a C program. And, of course, thestring values that will passed as parameters to your assembly-language function willdiffer from the examples just given.You have been provided with a starter file named part_a.asm. Note that most ofthe file currently consists of some assembler directives, allocations of memory forglobal variables (in the .data) section, and some driver code that interacts with theuser, calls FUNCTION_STRCMP, and outputs the value returned by that function. All ofyour solution for the first part of the assignment must appear in this function.There is also a large comment just before FUNCTION_STRCMP. It reads:############################################################ YOUR SOLUTION MAY NOT ADD MORE GLOBAL DATA OR CONSTANTS.# ALL OF THE CODE FOR YOUR FUNCTION(S) MUST APPEAR AFTER# THIS POINT. SUBMISSIONS THAT IGNORE THIS REQUIREMENT# MAY NOT BE ACCEPTED FOR EVALUATION.###########################################################This comment indicates a strict requirement for your solution. You are notpermitted to modify any of the code before this comment, or add any additional.data sections after the comment unless given express written permission bythe course instructor. Your function must operate correctly as it is called by thedriver code, and also work when during evaluation some of the constants (such asMAX_WORD_LEN,MAX_WORD_LEN_SHIFT or MAX_NUM_WORDS) are changed. Duringmarking your assignment will always be called with properly-formed input (i.e., wewill not be testing for error handling). Any changes to constants will be coherent,e.g., if MAX_WORD_LEN is changed to 64, then MAX_WORD_LEN_SHIFT will be changedto 6 (which means MAX_WORD_LEN will always be a power of 2).Part B: FUNCTION_SWAPThe code in part A does not modify the parameters passed to it. The code in thispart, however, must swap the contents of two strings. That is:Page 3 of 5 — Monday, February 25, 2019• The function receives the starting address of each string.• It copies the characters corresponding to the first string into a temporaryarea.• It then copies the characters corresponding to the second string into thememory of the first string.• Finally it copies the characters in the temporary area into the second string.The copying will involve using loops and the lbu and sb MIPS instructions. Furtherthe space for the temporary area must be obtained from the stack, which willinvolve increasing the size as the start of the function and decreasing it at the end ofthe function.You have been provided with a starter file named part_b.asm. Note that most ofthe file currently consists of some assembler directives, allocations of memory forglobal variables (in the .data) section, and some driver code that interacts with theuser and calls FUNCTION_SWAP. All of your solution for the second part of theassignment must appear in this function.The same strict requirements as described for part A also apply for part B withrespect to modifying the provided code.Part C: FUNCTION_PARTITION and FUNCTION_HOARE_QUICKSORTYou will need your work from parts A and B to complete part C. In fact, you will needcopy-and-paste your functions into the starter file provided to you (part_c.asm).(And, yes, the strict requirements are repeated for this part.) In this part your codewill sort an array of strings where the strings are input by the user; this input andoutput code is already provided to you.The quicksort implementation you are to write must be the one described in thisparticular section of the Wikipedia article for quicksort:https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_schemeFor operations such as:A[i] &lt; pivotyou will use your FUNCTION_STRCMP, and actions such as:swap A[i] with A[j]you will, of course, call upon your own FUNCTION_SWAP implementation.Page 4 of 5 — Monday, February 25, 2019The hardest task in this part will be the implementation of FUNCTION_PARTITION,and you must write this as a separate function. (In fact, once this function iscompleted, calling it from FUNCTION_QUICKSORT in a way that works is almostlaughingly easy.)Please make use of FUNCTION_PRINT_WORDS provided to you in part_c.asm as adebugging aid. You will find this will be an very helpful aid when debuggingFUNCTION_PARTITION.And two final cautions:• For all of the parts of this assignment, your implementations of the functionsmust properly save registers (at function start) and properly restoreregisters (at function end). If this is not properly done, you will run intoinfuriating bugs as registers in some function have their values changed in cacalled function in a way that you do not intend or desire. Put all of theregister-save code at the start of functions, and all register-restore code atthe end of functions. Do not intersperse save and restore code amongst therest of the function as that style of coding infuriatingly difficult to keepcorrect.• Beware of what you read on Stack Overflow and other places. You will findlots of hits for “MIPS” and “quicksort”, but the slough of despond into whichyou descend trying to figure out the postings will not be worth the visit.Many of those postings are aimed at new programmers or those unfamiliarwith many aspects of computer science. If you not only trust what you havelearned so far in CSC and SENG courses, but also use that knowledge as youattempt a solution from first principles, then you will find coding easier andmore successful.